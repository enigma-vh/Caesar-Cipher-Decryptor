import os
import random
import re
import sys
import time
from math import log

class ngram_score(object):
    '''
    The class ngram_score() is used to calculate the log probability, which is the 'fitness' of a piece of text.
    A higher score means it is more likely to be English, while a lower score means it is less likely to be English.
    '''

    def __init__(self, fp, sep = ' '):
        '''load a file containing quadgrams and its frequencies in English'''

        self.ngrams = {}
        for line in open(fp, "r"):
            key,frequency = line.split(sep)
            self.ngrams[key] = int(frequency)
        self.L = len(key)
        self.N = sum(self.ngrams.values())

        # calculate the log probabilities
        for key in self.ngrams.keys():
            self.ngrams[key] = log(float(self.ngrams[key])/self.N)
        self.floor = log(0.01/self.N)

    def score(self,text):
        '''compute the fitness of a text'''
        score = 0
        ngrams = self.ngrams.__getitem__
        for i in range(len(text)-self.L+1):
            if text[i:i+self.L] in self.ngrams:
                score += ngrams(text[i:i+self.L])
            else:
                score += self.floor
        return score


class sub_cipher_attack(object):

    alphabets = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

    # english_quadgrams.txt is the file that contains quadgrams and its frequencies
    fitness = ngram_score(os.path.join(sys.path[0], "english_quadgrams.txt"))

    def __init__(self, cipher):
        '''Because all the quadgrams in the file are uppercase, ciphertext need to be captialised for the fitness calculation'''
        cipher = re.sub('[^A-Z]', '', cipher.upper())
        self.cipher = cipher

    def decrypt(self, cipher, key):
        '''Decryption using substitution cipher'''
        text = ""
        for i in cipher:
            if i.isalpha():
                text += self.alphabets[key.index(i)]
            else:
                text += ""
        return text

    def attack_funtion(self):
        ''' Basic attack function using Hill Climbing algorithm

            Starting with a random key, then trying to swap the position of two elements in the key
            in order to search for a better result than the original key. This is done for all possible
            pairs of characters. If the better key is found, the process will start over again.

        : key: the main key for the decryption
        : endpoint: the limitation of the 'fitness' of a text
        : cur_key: the key that is generated by random shuffle
            : cur_limit: the 'fitness' of a text that is decrypted with the cur_key
        : output: Print out thr secret key
        : return: the plaintext
        '''

        key = list(self.alphabets)
        endpoint = -99e9
        cur_limit = endpoint
        cur_key = key[:]
        timeout = time.time() + 60 * 3
        i = 0
        while i < 1500:
            i += 1
            random.shuffle(cur_key)
            deciphered = self.decrypt(self.cipher, cur_key)
            cur_limit = self.fitness.score(deciphered)

            count = 0

            while count < 1000:
                # Randomly generate two index for swapping
                a = random.randint(0,25)
                b = random.randint(0,25)
                tmp = cur_key[:]

                # swap two characters in the temporary key
                tmp[a], tmp[b] = tmp[b], tmp[a]
                deciphered = self.decrypt(self.cipher, tmp)
                tmp_limit = self.fitness.score(deciphered)

                # if the temporary key is better, replace the cur_key with it
                if tmp_limit > cur_limit:
                    cur_limit = tmp_limit
                    cur_key = tmp[:]
                    count = 0
                count += 1


            # if the cur_key is better, replace the main key with the cur_key
            if cur_limit > endpoint:
                endpoint = cur_limit
                key = cur_key[:]

            if time.time() > timeout:
                break

        print('Secret key: ' + ''.join(key))
        return self.decrypt(self.cipher, key)



words = open(os.path.join(sys.path[0], "dictionary.txt")).read().split()
wordcost = dict((k, log((i+1)*log(len(words)))) for i,k in enumerate(words))
maxword = max(len(x) for x in words)

def insert_spaces(s):
    '''Uses dynamic programming to infer the location of spaces in a string without spaces.
        1. Find the best match for the i first characters, assuming cost has been built for the i-1 first characters.
        2. Returns a pair (match_cost, match_length).
    '''

    def best_match(i):
        candidates = enumerate(reversed(cost[max(0, i-maxword):i]))
        return min((c + wordcost.get(s[i-k-1:i], 9e999), k+1) for k,c in candidates)

    # Build the cost array.
    cost = [0]
    for i in range(1,len(s)+1):
        c,k = best_match(i)
        cost.append(c)

    # Backtrack to recover the minimal-cost string.
    out = []
    i = len(s)
    while i>0:
        c,k = best_match(i)
        assert c == cost[i]
        out.append(s[i-k:i])
        i -= k

    return " ".join(reversed(out))

def main():
    '''When you run the 4th cipher text, you will notice that the letter 'x' and 'v' have been misplaced,
        which I could not figure out how to fix it. '''

    ctext = input("Enter your cipher text : ")
    a = sub_cipher_attack(ctext)
    result = a.attack_funtion()
    print('Plaintext: ' + insert_spaces(result))


if __name__ == "__main__":
    start_time = time.time()
    main()
    print("--- %s second ---" % (time.time() - start_time))
